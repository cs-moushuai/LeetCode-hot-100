# [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

**难度: 中等**



*Description:*

```
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
```

![](/Users/world/code/leetcode/必做百题第二遍/ex34/ex42/rainwatertrap.png)



## 思路

* 动态规划

  ```
  对于下标 i，下雨后水能到达的最大高度等于下标 i 两边的最大高度的最小值，下标 i 处能接的雨水量等于下标 i 处的水能到达的最大高度减去height[i]。
  
  朴素的做法是对于数组 height 中的每个元素，分别向左和向右扫描并记录左边和右边的最大高度，然后计算每个下标位置能接的雨水量。假设数组 height 的长度为 n，该做法需要对每个下标位置使用 O(n) 的时间向两边扫描并得到最大高度，因此总时间复杂度是 O(n^2)
  
  上述做法的时间复杂度较高是因为需要对每个下标位置都向两边扫描。如果已经知道每个位置两边的最大高度，则可以在 O(n) 的时间内得到能接的雨水总量。使用动态规划的方法，可以在 O(n)的时间内预处理得到每个位置两边的最大高度。
  ```

* 单调栈

  ```
  除了计算并存储每个位置两边的最大高度以外，也可以用单调栈计算能接的雨水总量。
  
  维护一个单调栈，单调栈存储的是下标，满足从栈底到栈顶的下标对应的数组 height 中的元素递减。
  ```

* 双指针

  ```
  注意到下标 i 处能接的雨水量由 leftMax[i] 和rightMax[i] 中的最小值决定。由于数组leftMax 是从左往右计算，数组 rightMax 是从右往左计算，因此可以使用双指针和两个变量代替两个数组。
  ps:对比动态规划，优化了空间且双向进行
  ```

  